 ### TCP 三次握手

* 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）
* 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
* 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
  2.“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题
  client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。
### TCP四次挥手
* 客户端进程发出连接释放报文，并且停止发送数据。FIN=1。客户端进入FIN-WAIT-1（终止等待1）状态。
* 服务器收到连接释放报文，发出确认报文，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
* 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
* 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
* 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
* 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

### 连接是三次握手，关闭是四次握手
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
https://blog.csdn.net/qq_38950316/article/details/81087809

### TCP超时重传

* 原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。影响超时重传机制协效率的一个关键参数是重传超时时间（RTO，etransmission TimeOut）。RTO的值被设置过大过小都会对协议造成不利影响。
  * RTO设长了，重发就慢，没有效率，性能差。
  * RTO设短了，重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。 连接往返时间（RTT，Round Trip Time），指发送端从发送TCP包开始到接收它的立即响应所消耗的时间。
### TCP滑动窗口

* TCP的滑动窗口的可靠性也是建立在“确认重传”基础上的。发送窗口只有收到对端对于本端发送窗口内字节的ACK确认，才会移动发送窗口的左边界。 接收端可以根据自己的状况通告窗口大小，从而控制发送端的接收，进行流量控制。滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。拥塞窗口是发送方使用的流量控制，而滑动窗口则是接收方使用的流量控制。
### TCP的拥塞控制
拥塞控制是一个全局性的过程； 流量控制是点对点通信量的控制TCP拥塞控制4个核心算法：慢开始（slow start）、拥塞避免（Congestion Avoidance）、快速重传（fastretransmit）、快速回复（fast recovery）拥塞窗口（cwnd，congestion window），其大小取决于网络的拥塞程度，并且动态地在变化。
慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：当cwnd<ssthresh时，使用慢开始算法。
当cwnd>ssthresh时，改用拥塞避免算法。
当cwnd=ssthresh时，慢开始与拥塞避免算法任意
拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送发的拥塞窗口cwnd加1，而不是加倍。无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。
快速重传(Fast retransmit)要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。
快速恢复(Fast Recovery)
（1）当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
（2）由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。
“乘法减小”指的是无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半，并执行慢开始算法（指数增长），所以当网络频繁出现拥塞时，ssthresh下降的很快，以大大减少注入到网络中的分组数。“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止过早出现拥塞。常合起来成为AIMD算法。
### TCP UDP HTTP
物理层-数据链路-网络（IP协议）传输 （TCP协议）会话-表示层和应用层（HTTP协议）

* TCP：可靠，稳定
  TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

* TCP的缺点：
  慢，效率低，占用系统资源高，易被攻击
  TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。
  而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

* UDP：快，比TCP稍安全
  UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……

* UDP的缺点：
  不可靠，不稳定
  因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。
  UDP 用户数据报协议，是一个面向无连接的协议。采用该协议不需要两个应用程序先建立连接。UDP协议不提供差错恢复，不能提供数据重传，因此该协议传输数据安全性差。
  （1）、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
  （2）、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
  SYN攻击原理
        SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。SYN攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN攻击并不管目标是什么系统，只要这些系统打开TCP服务就可以      实施。从上图可看到，服务器接收到连接请求（syn=j），将此信息加入未连接队列，并发送请求包给客户（syn=k,ack=j+1），此时进入SYN_RECV状态。当服务器未收
        到客户端的确认包时，重发请求包，一直到超时，才将此条目从未连接队列删除。配      合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的 IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源      地址是不存在的，      服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。

* ​      9.HTTP各个版本区别
  ​      HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束      后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”
  ​      1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请      求后，就自动释放连接。
  ​      2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。
  ​      3）HTTP 2通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议      开销降到最低，同时增加了对请求优先级和服务器端推送的支持。HTTP/2有三大特性      ：头部压缩（原因：HTTP 请求和响应都是由「状态行、请求 / 响应头部、消息主      体」三部分组成。一般而言，消息主体都会经过 gzip 压缩，或者本身传输的就是压缩      过后的二进制文件（例如图片、音频），但状态行和头部却没有经过任何压缩，直接      以纯文本传输。随着 Web 功能越来越复杂，每个页面产生的请求数也越来越多，导致      头部会很长）、Server Push、多路复用。Server Push就是在某次流中，可以返回客      户端并没有主动要的数据。
  ​      由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要      保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时      不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连      接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服      务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到      服务器的回复，则认为网络已经断开（http1.0）。
  ​      Keep-Alive解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次      HTTP请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。在      HTTP1.1中是默认开启了Keep-Alive，他解决了多次连接的问题，但是依然有两个效      率上的问题：
  ​      1.串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处      理文件、服务器返回文件，这三个步骤。
  ​      2.连接数过多，就需要等待前面某个请求处理完成。
  ​      Http2的多路复用，HTTP/2的多路复用就是为了解决上述的两个性能问题。
  ​      \1. 解决第一个：在HTTP1.1的协议中，我们传输的request和response都是基本于文本      的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello      world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的      顺序，所以并行传输在HTTP1.1是不能实现的。HTTP/2引入二进制数据帧和流的概念      ，其中帧对数据进行顺序标识。这样浏览器收到数据之后，就可以按照序列对数据进      行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并      行的传输数据，这就是流所做的事情。
  ​      \2. HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，      也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的      并发就可以提升到300，比原来提升了6倍！
  ​      HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入      SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的      主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另      一种就是确认网站的真实性。
  ​      10.Http请求方式，请求头
  ​      GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取      POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交      HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响      应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全      部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看      服务器的性能      PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法      客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。
  ​      11.HTTPS和HTTP的区别主要如下：
  ​      1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。服务端发      送证书，也就是公钥私钥中的公钥给客户端，客户端通过该公钥计算得到在本次通信      中才使用的私钥，传递给服务端，服务端如果能正常解码该消息，则之后的通信都是      用该次通信对应的密钥进行      2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协      议。
  ​      3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是      443。
  ​      4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加      密传输、身份认证的网络协议，比http协议安全。
  ​      12.SOCKET
  ​      套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。包      含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的      协议端口，远地主机的IP地址，远地进程的协议端口。      应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服      务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输      数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP      ／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区      分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
  ​      建立socket连接
  ​      建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，      另一个运行于服务器端，称为ServerSocket 。
  ​          套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
  ​          服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状          态，实时监控网络状态，等待客户端的连接请求。
  ​          客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。          为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接          字的地址和端口号，然后就向服务器端套接字提出连接请求。
  ​          连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响          应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，
  ​          一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状          态，继续接收其他客户端套接字的连接请求。
  ​          socket通信流程
  ​          服务器根据地址类型（ipv4,ipv6）、socket类型、协议创建socket
  ​          服务器为socket绑定ip地址和端口号
  ​          服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的          socket并没有被打开
  ​          客户端创建socket
  ​          客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket          服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户          端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端          返回连接信息后才返回，开始接收下一个客户端谅解请求          客户端连接成功，向服务器发送连接状态信息
  ​          服务器accept方法返回，连接成功
  ​          客户端向socket写入信息
  ​          服务器读取信息
  ​          客户端关闭
  ​          服务器端关闭
  ​          Socket连接与HTTP连接
  ​          由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可          开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器          之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火          墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮          询告诉网络，该连接处于活跃状态。
  ​          而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要          客户端向服务器发出请求后，服务器端才能回复数据。
  ​          很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时          与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；          若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回          给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也          是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。
  ​          \13. Cookie and Session，Token
  ​          Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器          cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie          的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关          闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话          cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规          范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开          浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以          在不同的浏览器进程间共享，比如两个IE窗口。、         Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就          是使用散列表）来保存信息。
  ​          区别
  ​          1.存取方式的不同，Cookie中只能保管ASCII字符串，而Session中能够存取任何类型          的数据，包括而不限于String、Integer、List、Map等。
  ​          2.隐私策略的不同，Cookie存储在客户端阅读器中，对客户端是可见的，而Session存          储在服务器上，对客户端是透明的。假如选用Cookie，比较好的方法是，敏感的信息          如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加          密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。
  ​          3.有效期上的不同，Cookie可以方便的设置。Session依赖于名为JSESSIONID的          Cookie，而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越          容易招致内存溢出。
  ​          4.服务器压力的不同，Session是保管在服务器端的，每个用户都会产生一个Session          ，耗费大量的内存。而Cookie保管在客户端，不占用服务器资源         、

  ​          5.跨域支持上的不同，Cookie支持跨域名访问，而Session则不会支持跨域名访问。
  ​          Session仅在他所在的域名内有效。
  ​          Token :
  ​          token是用户身份的验证方式，我们通常叫它：令牌。最简单的token组成:uid(用户唯          一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算          法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还          可以把不变的参数也放进token，避免多次查库。
  ​          应用场景：
  ​          A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一          个 token 值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返          回给客户端.
  ​          B：客户端拿到 token 值之后,进行本地保存。（SP存储是大家能够比较支持和易于理          解操作的存储）
  ​          C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带          到参数中发送给服务器.
  ​          D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值          做对比
  ​          对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态!
  ​          对比二：如果没有这个 token 值, 则说明没有登录成功.
  ​          对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录.
  ​          session和 token并不矛盾，作为身份认证token安全性比session好，因为每个请求都          有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了
  ​          \14. OSI七层模型
  ​          OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层
  ​          （Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link
  ​          ）、物理层（Physical）。
  ​          应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，
  ​          SMTP，DNS，Telnet
  ​          表示层 数据格式化，代码转换，数据加密 没有协议
  ​          会话层 解除或建立与别的接点的联系 没有协议
  ​          传输层 提供端对端的接口 TCP，UDP
  ​          网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP
  ​          数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，
  ​          MTU
  ​          物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2
  ​          在OSI七层模型中ARP属于数据链路层， 在TCP/IP模型中ARP属于网络层
  ​          五层体系结构
  ​          五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。
  ​          网际层协议：包括：IP协议、ICMP协议、ARP协议、RARP协议。
  ​          传输层协议：TCP协议、UDP协议。
  ​          应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS
  ​          ARP协议，全称“Address Resolution Protocol”,中文名是地址解析协议，使用ARP协
  ​          议可实现通过IP地址获得对应主机的物理地址（MAC地址）
  ​          ICMP：一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通
  ​          ；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以
  ​          及丢包的原因。所以我们就需要一种协议来完成这样的功能–ICMP协议。
  ​          \15. HTTP过程
  ​          1.对www.baidu.com这个网址进行DNS域名解析(将主机名和域名转换为IP地址)，得到
  ​          对应的IP地址
  ​          2.根据这个IP，找到对应的服务器，发起TCP的三次握手
  ​          3.建立TCP连接后发起HTTP请求
  ​          4.服务器响应HTTP请求，浏览器得到html代码。Responds
  ​          5.浏览器解析html代码，并请求html代码中的资源（如js、css图片等）（先得到html
  ​          代码，才能去找这些资源）parsing
  ​          6.浏览器对页面进行渲染呈现给用户
  ​          HTTP请求过程
  ​          建立连接完毕以后客户端会发送响应给服务端
  ​          服务端接受请求并且做出响应发送给客户端
  ​          客户端收到响应并且解析响应给用户
  ​          HTTPS过程
  ​          客户端发送请求到服务器端
  ​          服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在
  ​          客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加
  ​          密发送到服务器端
  ​          服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
  ​          客户端使用共享密钥解密数据
  ​          SSL加密建立………
  ​          DNS过程
  ​          1.用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端
  ​          了 2.
  ​          浏览器将接收到的url中抽取出域名字段，就是访问的主机名，, 并将这个主机名传送给
  ​          DNS应用的客户端。
  ​          3.DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段
  ​          （中间包括一些列缓存查询以及分布式DNS集群的工作）
  ​          4.该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址。
  ​          5.一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP
  ​          连接。
  ​          16.TCP流量控制、拥塞控制
  ​          什么是流量控制？流量控制的目的？
  ​          如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组
  ​          丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制
  ​          根本目的是防止分组丢失，它是构成TCP可靠性的一方面。
  ​          如何实现流量控制？
  ​          由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接
  ​          收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口
  ​          的大小，并且利用大小来控制发送方的数据发送。
  ​          流量控制引发的死锁？怎么避免死锁的发生？
  ​          当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。
  ​          但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为
  ​          发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。
  ​          为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口
  ​          的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收
  ​          者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了
  ​          ，此时重置发送窗口后开始发送，这样就避免了死锁的产生。
  ​          拥塞控制和流量控制的区别
  ​          拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现
  ​          网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快
  ​          恢复。
  ​          流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来
  ​          得及接收，防止分组丢失的。
  ​          17.HTTP的报文格式
  ​          HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度
  ​          是不确定的。HTTP有两类报文：请求报文和响应报文。
  ​          请求报文
  ​          一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数
  ​          据4个部分组成。
  ​          请求行，请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们
  ​          用空格分隔。例如，GET /index.html HTTP/1.1。
  ​          请求头部，请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。
  ​          请求头部通知服务器有关于客户端请求的信息，典型的请求头有：
  ​          空行，最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再
  ​          有请求头。对于一个完整的http请求来说空行是必须的，否则服务器会认为本次请求
  ​          的数据尚未完全发送到服务器，处于等待状态。
  ​          请求数据，请求数据不在GET方法中使用，而是在POST方法中使用。
  ​          Http中 header主要来存放cookie，token等信息的 body主要用来存放post的一些数据  