# 排序算法
| 算法 | 时间复杂度  | 空间复杂度 | 备注| 稳定性|
| --- | --- | --- | --- | ----- |
| 选择排序  | N2  | 1    |    | × |
| 冒泡排序  | N2  | 1    |    | √ |
| 插入排序  | N ~ N2     | 1    | 时间复杂度和初始顺序有关 | √ |
| 希尔排序  | N 的若干倍乘于递增序列的长度 | 1     | 改进版插入排序 | × |
| 快速排序  | NlogN     | logN |         | × |
| 归并排序  | NlogN      | N   |          | √ |
| 堆排序    | NlogN     | 1   | 无法利用局部性原理    | × |

## 选择排序

* 从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。
* 选择排序需要 ~N2/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。

## 冒泡排序
* 从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出
## 插入排序
* 每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。
## 希尔排序

* 对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。

* 希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。

## 快速排序

- 归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；
- 快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。

## 归并排序

*  归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。 

## 堆排序

* 堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。

* 堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。