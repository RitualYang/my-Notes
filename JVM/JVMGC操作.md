## 垃圾回收策略

* 什么情况下该使用什么垃圾回收策略？
  * 在对内存要求苛刻的场景: 想办法提高对象的回收效率，多回收掉一些对象，腾出更多内存
  * 再CPU使用率高的情况下：降低高并发时垃圾回收的效率，让CPU更多地去执行你的业务而不是垃圾回收

## 判断对象存活

* 垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法。

#### 引用计数算法

* 引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。 
* 优缺点
  * 优点： 引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。 
  * 缺点： 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。 

#### 可达性分析算法

* 可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。 

* 在Java语言中，可作为GC Roots（根对象）的对象包括下面几种：
  
  1. 虚拟机栈中引用的对象（栈帧中的本地变量表）；
  
  2. 方法区中类静态属性引用的对象；
  
  3. 方法区中常量引用的对象；
  
  4. 本地方法栈中`JNI`（Native方法）引用的对象。

* 即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。
  
  * **第一次标记**：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；
  
  * **第二次标记**：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。在`finalize()`方法中没有重新与引用链建立关联关系的，将被进行第二次标记。
  
    （第二次标记成功的对象将真的会被回收，如果对象在`finalize()`方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。）

#### 引用

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用4种，这四种引用强度依次逐渐减弱。无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。

- 强引用：在程序代码中普遍存在的，类似 `Object obj = new Object()` 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 

- 软引用：用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。`SoftReference<String> sr = new  SoftReference<String>("hello");`

- 弱引用：也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。比如 `threadlocal`。`WeakReference<String> sr = new WeakReference<String>("hello");`

- 虚引用：也叫幽灵引用或幻影引用，是最弱的一种引用 关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了`PhantomReference`类来实现虚引用。当垃圾回收器准备回收一个对象时，如果发现它还有虚运用，就会再回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中，程序可以通过判断引用队列中是否已经加入虚引用，来来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么久可以在所引用的对象的内存被回收之前采取必要的行动。
  
  `ReferenceQueue<String> queue = new ReferenceQueue<String>();`
  
  `PhantomReference<String> pr = new PhantomReference<String>("hello", queue);`

### 垃圾收集算法

#### **引用计数法**

* 引用计数法实现简单，效率较高，在大部分情况下是一个不错的算法。其原理是：给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器加1，当引用失效时，计数器减1，当计数器值为0时表示该对象不再被使用。需要注意的是：引用计数法很难解决对象之间相互循环引用的问题，主流Java虚拟机没有选用引用计数法来管理内存。 

#### 标记-清除算法（Mark-Sweep）

* 标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。

* **缺点**：容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。  
  
  标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。

#### 复制算法(Copying)

* 为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。  

* 复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。

#### 标记-整理算法(Mark-compact)

* 为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动（先不清理，先移动再清理回收对象)，然后清理掉端边界以外的内存。  

* 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。

#### （JVM）分代收集算法 **（Generational Collection）**

* 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为**老年代**和**新生代**，在堆区之外还有**方法区**。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

* 目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的`Survivor`空间（一般为8:1:1），每次使用`Eden`空间和其中的一块`Survivor`空间，当进行回收时，将`Eden`和`Survivor`中还存活的对象复制到另一块`Survivor`空间中，然后清理掉`Eden`和刚才使用过的`Survivor`空间。
  
  而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法

#### (JVM) 增量算法

* 每次只收集一小片区域的内存空间的垃圾

### JVM回收类型

* 新生代回收（Minor GC | Young GC）
  
  * `eden`空间不足

* 老年代回收（Major GC）
  
  * 老年代空间不足（空间真的不够 或  垃圾碎片无法存放大对象）
  * 元空间不足
  * 要晋升到老年代的对象所占用的空间大于老年代的剩余空间
  * 显性调用了`System.gc()`
    * 建议垃圾回收器自己执行垃圾回收
    * `-XX:+DisableExplicitGC`参数，忽略掉`System.gc()`的调用

* 清理整个堆（Full GC）
  
  Major GC  ≈ Full GC

#### 垃圾收集在JVM中的使用

* 年轻代（`Young Generation`）的回收算法 (回收主要以Copying为主)
  1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
  2. 新生代内存按照8:1:1的比例分为一个eden区和两个`survivor(survivor0,survivor1)`区。一个`Eden`区，两个 `Survivor`区(一般而言)。大部分对象在`Eden`区中生成。回收时先将`eden`区存活对象复制到一个`survivor0`区，然后清空`eden`区，当这个`survivor0`区也存放满了时，则将`eden`区和`survivor0`区存活对象复制到另一个`survivor1`区，然后清空`eden`区·和这个`survivor0`区，此时`survivor0`区是空的，然后将`survivor0`区和`survivor1`区交换，即保持`survivor1`区为空， 如此往复。当`Eden`没有足够空间的时候就会 触发`jvm`发起一次`Minor GC`。
  3. 当`survivor1`区不足以存放 `eden`和`survivor0`的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次`Full GC(Major GC)`，也就是新生代、老年代都进行回收。
  4. 新生代发生的GC也叫做`Minor GC`，`MinorGC`发生频率比较高(不一定等`Eden`区满了才触发)。
* 老年代（`Old Generation`）的回收算法（回收主要以`Mark-Compact`为主）
  1. 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
  2. 内存比新生代也大很多(比例是1:2)，当老年代内存满时触发`Major GC`即`Full GC`，`Full GC`发生频率比较低，老年代对象存活时间比较长，存活率标记高。

### 注意

* 新键的对象不一定分配到`eden`区
  * 对象大于 `-XX:PretenureSizeThreshold`,就会直接分配到老年代区，默认值为0，不做限制
  * 新生代空间不够（新键对象大于新生代空间）
* 对象不一定要达到年龄(15次GC)才进入老年代
  * 动态年龄：如果`Survivor`空间中所有相同年龄对象大小的总和大于`Survivor`空间的一半，那么年龄大于等于该年龄的对象久可以直接进入老年代

### 术语

* Stop The World
  
  * 简称为STW，也叫全局停顿，Java代码停止运行，native代码继续运行，但是不能与JVM进行交互。
  * 原因：多半由于垃圾回收导致；也可能由Dump线程、死锁检查、Dump堆等导致。
  * 危害：服务停止、没有相应；主从切换、危害生产环境

* 并行收集
  
  * 多个垃圾收集线程并行工作，但是收集的过程中，用户线程(你的业务线程)还是处于等待状态的

* 并发收集
  
  * 用户线程与垃圾收集线程同时工作

* 吞吐量
  
  * CPU用于运行用户代码的时间与CPU总消耗时间的比值
  * 公式： 运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)