## 原子性

* 定义：原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做;如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。
* 实现原理：undo log
  * 在说明原子性原理之前，首先介绍一下MySQL的事务日志。MySQL的日志有多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中 redo log 用来保证事务持久性；undo log则是事务原子性和隔离性实现的基础。
  * undo log 是实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的就是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。
  * undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回来。
  * 以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列再修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。

### 持久性

* 定义：持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。
* 实现原理：redo log
  * redo log 和undo log 都属于InnoDB的事务日志。
  * redo log：InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存（Buffer Pool），Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool修改的数据会定期刷新到磁盘中(这一过程称为刷脏)
  * Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。
  * 于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log 记录这次操作；当事务提交时，会调用fsync接口对redo log 进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复，redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。

### 隔离性

* 与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。
* 隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能相互干扰。严格的隔离性，对应了事务隔离级别中的Serializable(可串行化),但实际应用中处于性能方面的考虑很少会使用可串行化。
* 隔离性追求的是并发情况下事务之间互不干扰。简单起见，我们主要考虑最简单的读操作和写操作（加锁读等特殊读操作会特殊说明），那么隔离性可以分为两个方面
  * （一个事务）写操作对（另一个事务）写操作的影响：锁机制保证隔离性
  * （一个事务）写操作对（另一个事务）读操作的影响：MVCC保证隔离性
* MVCC
  * 版本链
    * 我们数据库中的每行数据，除了我们肉眼看见的数据，还有几个隐蔽字段，得开天眼才能看见。分别是 `db_trx_id`、`db_roll_pointer`、`db_row_id`
    * db_trx_id  : 6byte，最近修改（修改/插入）事务ID：记录创建这条记录/最后一次修改该记录的事务ID。
    * db_roll_pointer（版本链关键）：7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
    * db_row_id：6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id 产生一个聚簇索引。
    * 实际还有一个删除filag隐藏字段，记录被更新或删除并不代表真的删除，而是删除flag变了。![表隐藏字段数据](..\images\mysql\表隐藏字段数据.png)

### 一致性

* 一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束 包括 但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。
* 可以说，一致性是事务追求的最终目标：前面提到原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。
* 实现一致性的措施包括：
  * 保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证
  * 数据库本身提供保障，例如不允许向整形列插入字符串值，字符串长度不超过列的限制等
  * 应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致性

### 事务的可靠性



缓冲池中更新完数据后，需要将本次的更新信息顺序写到Redo Log日志以及Binlog日志中（此时信息还在内存中，后续的刷盘策略如图所示），一般我们为了保证数据不丢失会配置双1策略，Redo Log落盘后，写Binlog落盘，再将Binlog的文件名、文件所在路径信息以及commit标记给同步顺序写到Redo log中（其中以commit标记是否更新到Redo Log中，是判定事务是否成功提交的一个比较重要的标准），Redo Log和BinLog分别在物理和逻辑层面为本次事务、提供数据上的一致性保障。