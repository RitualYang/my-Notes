# 数据库原理

### 数据库三大范式

1. 第一范式：表中每个字段都不能再分。
2. 第二范式：满足第一范式并且表中的非主键字段都依赖于主键字段。
3. 第三范式：满足第二范式并且表中的非主键字段必须不传递依赖于主键字段，每一列数据和主键直接相关。  

### 数据库事务（ACID）

* 事务具有四大特性：**一致性**、**原子性**、**隔离性**、**持久性**。
  * 原子性( Atomicity )：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。
  * 一致性(  Consistency )：事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。
  * 隔离性(  Isolation )：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
  * 持久性 ( Durability )：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。
* 数据库事务是指：几个SQL语句，要么全部执行成功，要么全部执行失败。比如银行转账就是事务的典型场景。
* 数据库事务的四种常用命令：`Begin Transaction`（启动事务）、`Start Transaction`、`Commit` （提交事务）、`RollBack` （回滚事务）。  

### 视图

* 视图实际上是在数据库中通过Select查询语句从多张表中提取的多个表字段所组成的虚拟表。

  > 1. 视图并不占据物理空间，所以通过视图查询出的记录并非保存在视图中，而是保存在原表中。
  > 2. 通过视图可以对指定用户隐藏相应的表字段，起到保护数据的作用。
  > 3. 在满足一定条件时，可以通过视图对原表中的记录进行增删改操作。
  > 4. 创建视图时，只能使用单条select查询语句。  

### 索引

* 索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。是一种快速查询表中内容的机制，类似于字典。  运用在表中某个些字段上，但存储时，独立于表外。索引一旦建立，数据库管理系统会对其进行自动维护，而且由数据库管理系统决定何时使用索引。用户不用再查询语句中指定使用哪个索引。在定义primary key或unique约束后系统自动在想印的列上创建索引,用户也能按自己的需求，对指定单个字段或多个字段，添加索引。  

* 索引分为：聚集索引、非聚集索引、唯一索引等。

  > 一张表可以有多个唯一索引和非聚集索引，但最多只能有一个聚集索引。
  > l 索引可以包含多列。
  > l 合理的创建索引能够提升查询语句的执行效率，但降低了新增、删除操作的速度，同时也会消耗一定的数据库物理空间。

* 索引使用
  * 什么时候要创建索引 
    * 表经常进行 SELECT 操作
    * 表很大(记录超多)，记录内容分布范围很广
    * 列名经常在 WHERE 子句或连接条件中出现  

  * 什么时候不要创建索引 
    * 表经常进行 INSERT/UPDATE/DELETE 操作
    * 表很小(记录超少)
    * 列名不经常作为连接条件或出现在 WHERE 子句中  

* 索引优缺 

  * 索引加快数据库的检索速度

  * 索引降低了插入、删除、修改等维护任务的速度(虽然索引可以提高查询速度，
    但是它们也会导致数据库系统更新数据的性能下降，因为大部分数据更新需要
    同时更新索引)

  * 唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中
    使用优化隐藏器，提高系统的性能

  * 索引需要占物理和数据空间

* 索引分类
  * 唯一索引​：唯一索引不允许两行具有相同的索引值。
  * 主键索引​：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空。
  * 聚集索引​(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个。
  * 非聚集索引​(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个。

### 存储过程

* 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

* 存储过程的优点：
  * 能够将代码封装起来；
  * 保存在数据库之中；
  * 让编程语言进行调用；
  * 存储过程是一个预编译的代码块，执行效率比较高；
  * 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率。
  
* 存储过程的缺点：
  * 每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）。
  * 业务逻辑放在数据库上，难以迭代。
  
  ```sql
  create procedure 名称()
  begin
  .........
  end
  ```

(预编译又称为预处理，是做些代码文本的替换工作。处理#开头的指令，比如拷贝#include包含的文件代码，#define宏定义的替换,条件编译等就是为编译做的预备工作的阶段主要处理#开始的预编译指令)  

### 触发器

* 触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。  

  ```sql
  CREATE <触发器名> < BEFORE | AFTER >
  <INSERT | UPDATE | DELETE >
  ON <表名> FOR EACH Row<触发器主体>
  ```
* 触发器名
  
  * 触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。
  
* INSERT | UPDATE | DELETE

  * 触发事件，用于指定激活触发器的语句的种类。
      **注意：三种触发器的执行时间如下。**
  * INSERT：将新行插入表时激活触发器。例如，INSERT 的 BEFORE 触发器不仅能被 MySQL 的 INSERT 语句激活，也能被 LOAD DATA 语句激活。
  * DELETE： 从表中删除某一行数据时激活触发器，例如 DELETE 和 REPLACE 语句。
  * UPDATE：更改表中某一行数据时激活触发器，例如 UPDATE 语句。

* BEFORE | AFTER

  BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。

### 数据库约束  

* 数据库约束用于保证数据库表数据的完整性（正确性和一致性）。可以通过定义约束\索引\触发器来保证数据的完整性。总体来讲,约束可以分为:
  * 主键约束：primary key；
  * 外键约束：foreign key；
  * 唯一约束：unique；
  * 检查约束：check；
  * 空值约束：not null；用于控制字段的值范围。
  * 默认值约束：default  

### 超键，候选键，主键，外键

* 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为  一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
* 候选键(候选码)：是最小超键，即没有冗余元素的超键。
* 主键(主码)：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组  合。一个数据列只能有一
* 主键，且主键的取值不能缺失，即不能为空值（Null）。
  外键：在一个表中存在的另一个表的主键称此表的外键。  

### B+树

* [漫画叙述B+树和B-树](https://blog.csdn.net/qq_35571554/article/details/82759668)

### 聚合函数

MySQL提供了许多聚合函数，包括`AVG`，`COUNT`，`SUM`，`MIN`，`MAX`等。除`COUNT`函数外，其它聚合函数在执行计算时会忽略`NULL`值。（***没有对应数据时。count返回0，其他函数可以返回null***）

* AVG：计算一组值的平均值。 它计算过程中是忽略`NULL`值的。

* COUNT：返回表中的行数。
* SUM：返回一组值的总和，SUM()函数忽略`NULL`值。如果找不到匹配行，则SUM()函数返回`NULL`值。
* MAX：返回一组值中的最大值。 
* MIN：返回一组值中的最小值 。

* WHERE 和 HAVING 的基本区别如下：
  *  WHERE 在分组和聚集计算之前选取输入行（它控制哪些行进入聚集计算），WHERE 子句不能包含聚集函数。 
  * HAVING 在分组和聚集之后选取分组的行。HAVING 子句总是包含聚集函数。  

### drop、truncate、delete区别

* `drop`直接删掉表。
* `truncate`删除表中数据，再插入时自增长`id`又从1开始。
* `delete`删除表中数据，可以加`where`字句  

### 非关系型数据库和关系型数据库  

* 非关系型数据库的优势：
  * 性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
  * 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
  
* 关系型数据库的优势：
    * 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
    * 事务支持：使得对于安全性能很高的数据访问要求得以实现 。

### like %和_的区别

* %百分号通配符：表示任何字符出现任意次数(可以是0次)。
* _下划线通配符：表示只能匹配单个字符,不能多也不能少,就是一个字符。

###   B+Tree索引和Hash索引

* Hash索引和B+树索引的特点
  * Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;
    *  Hash索引仅仅能满足`=`,`IN`查询，不能使用范围查询。
    *  Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高 。  

  * B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;
    *  B+的磁盘读写代价更低。（io次数低）
    *  B+tree的查询效率更加稳定。（除索引外，所有数据存放在叶子结点）  


###   锁的基本概念

* 当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。

* 共享锁（Shared Lock，也叫S锁）
  共享锁(S)表示对数据进行读操作。因此多个事务可以同时为一个对象加共享锁。

* 排他锁(Exclusive Lock，也叫X锁)
  排他锁表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。

* 锁的粒度

  * 就是通常我们所说的锁级别。MySQL有三种锁的级别：页级、表级、行级。

  * 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。对整个表加锁，影响标准的所有记录。通常用在DDL语句中，`如DELETE`，`TABLE`，`ALTER TABLE`等。

  * 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。对一行记录加锁，只影响一条记录。通常用在DML语句中，如`INSERT`, `UPDATE`, `DELETE`等。

  * 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

#### 乐观锁
* 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。

#### 悲观锁

* 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
